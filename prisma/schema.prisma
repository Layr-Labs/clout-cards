// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/**
 * Event table - append-only log of all RPC calls processed by the TEE
 * 
 * This table maintains an immutable audit trail of all RPC calls that mutate
 * logical state. Each event represents a complete RPC call (not individual
 * table mutations), providing higher-level control and easier verification.
 * 
 * Events are signed by the TEE using EIP-712 signatures on the payload_json.
 * The digest is computed from the canonical JSON payload using typed data signing.
 */
model Event {
  eventId       Int      @id @default(autoincrement()) @map("event_id")
  blockTs       DateTime @map("block_ts") // When the event was finalized at the TEE
  player        String?  @db.VarChar(42) // Optional - whoever the event concerns
  kind          String   // Event kind: deposit, withdraw, bet, hand_start, hand_end, join_table, etc.
  payloadJson   String   @map("payload_json") @db.Text // Raw canonical JSON input used to mutate logical state (stored as TEXT, can be migrated to JSONB later)
  digest        String   @db.Char(66) // EIP-712 digest of payload_json, typed
  sigR          String   @map("sig_r") @db.VarChar(66) // Signature component R (32 bytes, stored as hex string with 0x prefix)
  sigS          String   @map("sig_s") @db.VarChar(66) // Signature component S (32 bytes, stored as hex string with 0x prefix)
  sigV          Int      @map("sig_v") // Signature component V
  nonce         BigInt?  // Monotonic per-player replay-protection nonce for withdrawal events only
  teeVersion    Int      @map("tee_version") // Version of the TEE binary that generated this event
  teePubkey     String   @map("tee_pubkey") @db.VarChar(66) // TEE public key that signed this event
  ingestedAt    DateTime @default(now()) @map("ingested_at") // When the backend inserted it (not part of digest)

  @@index([player])
  @@index([kind])
  @@index([blockTs])
  @@index([digest])
  @@map("events")
}

/**
 * Poker table configuration
 * 
 * Represents a poker table with its game parameters (blinds, buy-ins, rake, seat count).
 * Tables can be created, activated/deactivated, and searched by buy-in ranges.
 */
model PokerTable {
  id            Int      @id @default(autoincrement()) @map("poker_table_id")
  name          String   @unique @db.VarChar(255) // Unique table name/identifier
  minimumBuyIn  BigInt   @map("minimum_buy_in") // Minimum buy-in in gwei
  maximumBuyIn  BigInt   @map("maximum_buy_in") // Maximum buy-in in gwei
  perHandRake   Int      @map("per_hand_rake") // Rake per hand in basis points (bps), e.g., 100 = 1% (must be >= 0)
  maxSeatCount  Int      @map("max_seat_count") // Maximum number of seats (0-8)
  smallBlind    BigInt   @map("small_blind") // Small blind amount in gwei
  bigBlind      BigInt   @map("big_blind") // Big blind amount in gwei
  isActive      Boolean  @default(true) @map("is_active") // Whether the table is currently active
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  @@index([minimumBuyIn, maximumBuyIn]) // Composite index for buy-in range searches
  @@map("poker_tables")
}

/**
 * Player escrow balance
 * 
 * Tracks the on-chain escrow balance for each player wallet address.
 * This balance is updated when Deposited() events are detected from the CloutCards contract.
 * Balance is stored in gwei (wei / 10^9) for precision.
 */
model PlayerEscrowBalance {
  walletAddress String   @id @db.VarChar(42) @map("wallet_address") // Ethereum address (primary key)
  balanceGwei   BigInt   @map("balance_gwei") // Escrow balance in gwei
  updatedAt     DateTime @updatedAt @map("updated_at") // Last update timestamp

  @@map("player_escrow_balances")
}
