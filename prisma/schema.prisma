// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/**
 * Event table - append-only log of all RPC calls processed by the TEE
 * 
 * This table maintains an immutable audit trail of all RPC calls that mutate
 * logical state. Each event represents a complete RPC call (not individual
 * table mutations), providing higher-level control and easier verification.
 * 
 * Events are signed by the TEE using EIP-712 signatures on the payload_json.
 * The digest is computed from the canonical JSON payload using typed data signing.
 */
model Event {
  eventId       Int      @id @default(autoincrement()) @map("event_id")
  blockTs       DateTime @map("block_ts") // When the event was finalized at the TEE
  player        String?  @db.VarChar(42) // Optional - whoever the event concerns
  kind          String   // Event kind: deposit, withdraw, bet, hand_start, hand_end, join_table, etc.
  payloadJson   String   @map("payload_json") @db.Text // Raw canonical JSON input used to mutate logical state (stored as TEXT, can be migrated to JSONB later)
  digest        String   @db.Char(66) // EIP-712 digest of payload_json, typed
  sigR          String   @map("sig_r") @db.VarChar(66) // Signature component R (32 bytes, stored as hex string with 0x prefix)
  sigS          String   @map("sig_s") @db.VarChar(66) // Signature component S (32 bytes, stored as hex string with 0x prefix)
  sigV          Int      @map("sig_v") // Signature component V
  nonce         BigInt?  // Monotonic per-player replay-protection nonce for withdrawal events only
  teeVersion    Int      @map("tee_version") // Version of the TEE binary that generated this event
  teePubkey     String   @map("tee_pubkey") @db.VarChar(66) // TEE public key that signed this event
  ingestedAt    DateTime @default(now()) @map("ingested_at") // When the backend inserted it (not part of digest)

  @@index([player])
  @@index([kind])
  @@index([blockTs])
  @@index([digest])
  @@map("events")
}

/**
 * Poker table configuration
 * 
 * Represents a poker table with its game parameters (blinds, buy-ins, rake, seat count).
 * Tables can be created, activated/deactivated, and searched by buy-in ranges.
 */
model PokerTable {
  id            Int      @id @default(autoincrement()) @map("poker_table_id")
  name          String   @unique @db.VarChar(255) // Unique table name/identifier
  minimumBuyIn  BigInt   @map("minimum_buy_in") // Minimum buy-in in gwei
  maximumBuyIn  BigInt   @map("maximum_buy_in") // Maximum buy-in in gwei
  perHandRake   Int      @map("per_hand_rake") // Rake per hand in basis points (bps), e.g., 100 = 1% (must be >= 0)
  maxSeatCount  Int      @map("max_seat_count") // Maximum number of seats (0-8)
  smallBlind    BigInt   @map("small_blind") // Small blind amount in gwei
  bigBlind      BigInt   @map("big_blind") // Big blind amount in gwei
  isActive      Boolean  @default(true) @map("is_active") // Whether the table is currently active
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  @@index([minimumBuyIn, maximumBuyIn]) // Composite index for buy-in range searches
  
  // Relations
  seatSessions    TableSeatSession[]

  @@map("poker_tables")
}

/**
 * Player escrow balance
 * 
 * Tracks the on-chain escrow balance for each player wallet address.
 * This balance is updated when Deposited() events are detected from the CloutCards contract.
 * Balance is stored in gwei (wei / 10^9) for precision.
 * 
 * Also tracks pending withdrawal state to prevent race conditions:
 * - nextWithdrawalNonce: The nonce that will be used for the next withdrawal signature
 * - withdrawalSignatureExpiry: When the current withdrawal signature expires (if pending)
 */
model PlayerEscrowBalance {
  walletAddress            String    @id @db.VarChar(42) @map("wallet_address") // Ethereum address (primary key)
  balanceGwei             BigInt    @map("balance_gwei") // Escrow balance in gwei
  nextWithdrawalNonce     BigInt?   @map("next_withdrawal_nonce") // Next withdrawal nonce (nullable if never withdrawn)
  withdrawalSignatureExpiry DateTime? @map("withdrawal_signature_expiry") // Expiry timestamp of pending withdrawal signature (nullable)
  updatedAt                DateTime  @updatedAt @map("updated_at") // Last update timestamp

  @@map("player_escrow_balances")
}

/**
 * Table seat session
 * 
 * Tracks when a player sits down at a specific seat at a poker table.
 * This model combines the table, seat, player's running table balance, and session state.
 * 
 * Constraints:
 * - A player can only be active at one table at a time (enforced by unique constraint on walletAddress where isActive=true)
 * - A seat can only be occupied by one active player at a time (enforced by unique constraint on tableId+seatNumber where isActive=true)
 * - Table balance is encumbered from the player's escrow balance when they join
 * - When a player stands up, their table balance (winnings/losses) is moved back to escrow
 */
model TableSeatSession {
  id              Int      @id @default(autoincrement()) @map("table_seat_session_id")
  tableId         Int      @map("table_id") // Foreign key to PokerTable
  walletAddress   String   @db.VarChar(42) @map("wallet_address") // Player's wallet address
  seatNumber      Int      @map("seat_number") // Seat number (0-7)
  tableBalanceGwei BigInt  @map("table_balance_gwei") // Player's balance at this table (in gwei)
  twitterHandle   String?  @db.VarChar(255) @map("twitter_handle") // Player's Twitter/X handle (optional, not unique)
  twitterAvatarUrl String? @db.VarChar(500) @map("twitter_avatar_url") // Player's Twitter/X profile image URL (optional)
  joinedAt        DateTime @default(now()) @map("joined_at") // When the player sat down
  leftAt          DateTime? @map("left_at") // When the player stood up (nullable)
  isActive        Boolean  @default(true) @map("is_active") // Whether the session is currently active

  // Foreign key relationships
  table           PokerTable @relation(fields: [tableId], references: [id], onDelete: Cascade)

  @@unique([tableId, seatNumber, isActive], name: "unique_active_seat")
  @@unique([walletAddress, isActive], name: "unique_active_player")
  @@index([tableId])
  @@index([walletAddress])
  @@index([isActive])
  @@map("table_seat_sessions")
}
